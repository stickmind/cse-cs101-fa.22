---
type: assignment
date: 2022-10-17T8:00:00+00:00
title: '作业 4. Recursive Backtracking'
attachment: /static_files/assignments/asg.zip
due_event:
    type: due
    date: 2022-10-23T23:59:59+00:00
    description: '作业 4 截至'
---

递归是一个强大的问题求解工具，有大量的实际应用。本次作业精选了一些递归问题，每个递归问题都有其有趣之处。学习递归有一些挑战性，尤其是在学习初期。在把递归集成到更大的程序之前，最好先单独训练递归——别忘了，在课程后期，我们还会将递归集成到一个更大的程序中！当你完成这个作业时，你会对递归的艺术有一个更深刻的理解，并可以识别你能够处理的递归问题的类别。

大多数同学会发现，递归思维需要一些时间才能适应。所以，建议你尽早开始这次作业。仔细阅读问题描述，让你的大脑开始思考它。虽然没有大量的代码供你编写，但是你要给自己足够的时间来理解这种解决问题的新方法。虽然最终的递归解决方案中，可能只是几行优雅的代码，但是你在每一行上都将付出大量工作。递归代码可能是密集而复杂的，所以需要绞尽脑汁才能领会其中的细节。

仔细研究这些小而具有针对性的问题所涉及到的基础概念。本课程会继续探讨更高级的递归应用。慢慢的，你会对递归求解越来越得心应手。

---

这是递归问题的第二部分，我们将会使用递归回溯的强大特性，解决一些实际问题。在第一部分中，我们已经夯实了递归基础知识，现在你将能够很好地运用这个技能，来解决一些现实世界中的问题。

## 目标

- 通过将问题划分为一个或多个 Base Case 和 Recursive Case 来开发递归算法。
- 利用递归回溯技术，解决迭代方法无法轻松解决的问题。
- 实现更高级的递归算法，解决迭代方法无法轻松解决的问题。

## 第一部分 递归回溯热身

> 对递归函数进行单元测试和调试。

当你在程序中遇到 bug 时，你的第一反应通常是问“为什么我的程序不能做我想让它做的事情？”找到这个答案的最好方法之一就是从一个不同的问题开始: “我的程序在做什么，为什么它与我想要的不同？”

调试器是一个强大的工具，可以准确地观察程序正在做什么。通过观察程序执行时发生的情况，你就可以思考下一个问题，即中间结果是否与你在代码中表达的内容一致，以及如何更改代码以反映你的意图。

这个热身练习将带你练习如何在复杂的递归问题中使用调试器。

### 汉诺塔动画

汉诺塔作为一个经典的谜题，它有一个美丽的递归解。在这个调试器练习中，我们将研究这个问题的一个版本，该版本还计算解决这个难题需要多少步。

`warmup.cpp` 包含了一个正确的解决汉诺塔问题的方案，以及一个漂亮的图形动画。在 `warmup.cpp` 中运行测试来观看动画，看看这个小小的递归函数是如何做到这么多的。是不是很神奇？

现在让我们深入调试器，看看优雅的递归背后的机制。

### 调试器 Step 命令

热身的第一部分是探索调试器中不同类型的 `Step` 命令，以及这些命令与跟踪递归代码的关系。单步执行的控件位于 **Qt Creator** 中调试器视图的中间工具栏上。

从左到右的五个图标是 Continue, Stop, Step Over, Step Into 和 Step Out 的按钮。如果将鼠标悬停在 Qt 中的图标上，将弹出一个提示标签，提醒你该按钮的名称。

在 `warmup.cpp` 中的 `hanoiAnimation` 函数的第一行设置断点。在 Debug 模式下运行程序，当出现提示时，运行 `warmup.cpp` 的测试。

**Step Over**

停在断点时，在编辑器的代码行前找到黄色箭头。程序在这一行之前停止。右上方的变量面板显示 `numDiscs` 和 `talMoves` 变量。由于这些变量尚未初始化，因此它们的值未指定；它们可能是 0，也可能是随机垃圾值。

使用 Step Over 来浏览 `hanoiAnimation` 函数的每一行：

1. Step Over 对 `numDiscs` 初始化。变量面板将更新显示其值。黄色箭头指向下一行。
1. Step Over 函数 `HanoiGui::initialize`。函数将根据初始配置设置图形窗口并显示。
1. Step Over 暂停函数 `pause`，你将注意到函数执行时的短暂延迟。
1. Step Over 初始化 `totalMoves`，并在变量面板中注意其更新值。
1. Step Over 函数 `moveTower` 调用并观看整个 `moveTower` 序列的执行和动画。这是一大步！

> Q1: 在 `hanoiAnimation` 中越过 `moveTower` 调用之后，`totalMoves` 的值是什么？

**Step Into**

现在让我们练习 Step Into 操作。与 Step Over 不同，Step Into 进入被调用的函数内部，这样你就可以单步执行它的内部操作。如果要执行的下一行不包含函数调用，Step Into 将和 Step Over 效果相同。

重新启动该程序，在 hanoiAnimation 的第一行上设置一个断点，并在调试模式下运行。

1. Step Into 初始化 numDiscs。由于该行没有函数调用，因此 Step Into 与 Step Over 相同，只执行单个语句。
1. 现在进入 HanoiGui::initialize 调用。
    - 编辑器将切换显示 hanoigui.cpp 文件的内容，黄色箭头指向 initialize 函数的第一行。这段代码是陌生的，你没有编写它，也没有打算跟踪它。
    - Step Out 可以返回原来的位置。这将完成当前的函数。在这里使用 Step Out 时，它将执行 HanoiGUI::initialize 函数的所有其余部分，并将返回到 hanoiAnimation。
2. 接下来是 pause 函数，另一个库函数，你也不想跟踪其内部。你可以 Step Into 看一下，然后 Step Out 出来，但是直接 Step Over 更简单。
3. 你感兴趣的是跟踪 moveTower 函数内部，因此使用 Step Into 进入其内部。一旦进入 moveTower 函数，Step Over 每一行，继续执行 else 语句中的递归子调用。当你 Step Over 递归子调用 moveTower 时，GUI 窗口应该会显示将三个盘子从左边移动到中间的动画。totalMoves 的值将更新所有移动步数。

> Q2: 在 Step Over 第一个递归子调用之后，totalMoves 变量的值是什么？（换句话说，在 else 语句中，只要 Step Over 第一个递归子调用 moveTower就可以执行 moveTower)

下一个 Step Over 将最大的圆盘从左边移动到右边。最后一步 Step Over 将从中间到右边移动三个盘子。

**Step Out**

现在让我们练习 Step Out 调试器操作。删除其他断点，并在 moveTower 的 Base Case 中设置一个断点（在 if 语句中代码的第一行）。在调试模式下运行程序，在断点处停止时，请使用 Step Out。

> Q3. 在 moveTower 的 Base Case 满足时选择 Step Out，你最终会在哪里结束？（你在哪个函数中，行号是多少？）此时，totalMoves 变量的值是多少？

**Practice with Step Into/Over/Out**

理解不同 Step 操作是增进你对递归及其机制理解的一个很好的方法。重新运行程序，再次停止在调试器中，并尝试做一些跟踪和探索。在观看动画时，请考虑移动盘子是如何与递归调用相关联的。观察栈帧是如何从调试器调用栈中添加和删除的。停止后，在调用栈上选择不同的级别，查看变量面板中的参数值和递归调用的嵌套关系。以下是关于何时使用每种 Step 的一些建议：

- Step Over 在使用整体观思考递归调用时很有用。递归调用是一个完整的“黑盒”，它会处理所有子问题。
- Step Into 允许你从外部递归调用，移动到内部递归调用，并跟踪实际的递归调用细节。
- Step Out 允许你从内部递归调用，回到外部递归调用。

Step In、 Step Over 和 Step Out 允许你观察不同级别的递归工作。Step In 可以让你看到每个时间点上发生了什么。Step Over 让你看到递归函数的整体功能。Step Out 允许你执行完当前函数，并查看代码的整体行为。

### 测试并调试错误的子集求和问题

你的下一个任务是使用调试器来完成它的原始目的——调试程序！

生成集合中所有可能的子集，使用的是 include/exclude 经典递归范式。决策树中的每个节点，根据是否包含一个待考虑的元素，将其分为两个递归调用，一个包含该元素，另一个排除该元素。决策树会生长到 N 的深度，其中 N 是集合中的元素总数。

这个热身练习提供一个 countZeroSumSubset 函数，它是一个正确实现的函数，用于探索输入的所有子集，并计算其成员总和为零的子集。例如输入 `{3, 1, -3}` 会枚举出所有的子集 `{ {3, 1, -3}, {3, 1}, {3, -3}, {1, -3}, {3}, {1}, {-3}, {} }`。其中的两个 `{3, -3}` 和 `{}` 元素总和为 0，所以函数返回 2。在调试之前，确认你理解该函数的实现。

除了正确的实现之外，还有一个 buggyCount 版本，其中包含一个很小但很重要的错误。它离正确实现并不遥远——事实上，它降低了一个字符的差异——但是一个字符也会带来很大的问题！你的任务是使用调试器来解决以下问题：

- 首先，观察 bug 函数的行为与预期的有什么不同？
- 现在研究代码：函数实际上做了什么，从而产生了不正确的结果？
- 最后，如何更改代码修复 bug。

假设你刚刚编写了 buggyCount 版本，现在要对其进行测试。与往常一样，你的测试策略是添加各种测试用例，以此确认函数是否正确工作。当你发现输入不能返回正确的答案时，这些输入将指引你调试调试需要的地方。

现在添加各种测试用例，并使用它们来观察生成的和应该生成的之间的差异。当你跟踪一系列递归调用时，可能很难理解 bug 的影响。尝试将输入细化到可以观察到错误的最小可能输入，并将其用作测试用例。具体来说，你的目标是找到一个输入

- 产生的输出是错误的，并且
- 没有更小的输入案例可以产生同样的错误

使用最小化的测试用例，跟踪 `countZeroSumSubsets` 的操作以观察正确的行为。将正在遍历的决策树在草稿纸上画出来，并将该树与 Step In/Out/Over 在调试器中看到的结果进行对比。在调用栈中选择不同的栈帧，查看每个外部帧中的程序状态。

在熟悉正确版本的执行逻辑之后，现在对同一输入用例跟踪 `buggyCount` 的行为。仔细观察在这个过程中哪些地方出现了错误，以及背后的原因。

> Q4. 你用来触发程序错误的最小可能输入是什么？

> Q5. 识别代码中的单字符错误，并解释为什么单字符错误会导致上述测试案例中的错误返回结果。你应该能够具体说明错误是如何导致结果从“完全正确”变为“严重错误”的。

当调试递归函数时，先寻找函数出错的最小测试案例。一个小的测试案例可以很容易地重现错误，并跟踪调试器中发生的情况。与其对可能出错的地方提出不切实际的推测，不如使用调试器进行单步调试并观察结果，调查可能出错的地方。将这些观察结果与代码联系起来，找到修复它的办法，以正确反映你的意图。

虽然我们是在调试递归函数时引入了这些技术，但是找到一个最小可重复性的测试案例，对于调试任何类型的代码来说都是一种有效的策略。

## 第二部分 拼字游戏

在给定的拼字板上查找所有单词并计算最大可能得分。

### 游戏简介

这个拼字游戏 Boggle™ 是本课程中非常有趣的部分，因为它出色地使用了递归搜索。该游戏核心的递归问题是：找到拼字盘上所有单词并达到尽可能高的分数。

游戏是在一个方形网格中，随机分配一组字母立方体。你可以通过相邻的字母立方体按顺序构造出一个单词，每个单词最多使用一次立方体。游戏板将表示为 `Grid<char>`。网格中的每个位置都是一个字母立方体，该网格位置的字符是立方体顶部的字母。

如果一个单词满足以下所有条件，则该词对给定的游戏板有效：

- 单词必须至少有 4 个字母。
- 单词必须包含在有效的英语单词列表中。
  - 我们提供英语单词表，你可以使用它来检查。
- 单词可以通过跟踪相邻的字母立方体路径来形成，最多使用一次立方体。
  - 在字母板上，立方体沿着四个基线方向和四个对角线方向彼此相邻。每个立方体有 3 到 8 个邻居，这取决于它在板上的位置。）
- 单词不能重复记分，每个单词只记分一次。

一个单词的分数根据其长度进行评分。根据上述标准，具有 3 个或更少字符的单词无效，因此记零分。一个 4 个字母的单词获得 1 分；一个 5 个字母的单词获得 2 分；6 个字母的单词获得 3 分；以此类推。

先熟悉游戏规则，并思考用什么算法来解决这个游戏，请先尝试在线版 Boggle 游戏，看看这种递归回溯的实际应用。

### 你的任务

你需要编写一个函数，计算给定 Boggle 板上所有单词的总分数。函数原型如下：

```c++
int scoreBoard(Grid<char>& board, Lexicon& lex)
```

该函数通过递归探索拼字盘来查找所有单词并计算点数。在设计解决这个问题的递归方法时，请考虑以下两个重要想法：

- 回溯。在字母板上搜索单词是递归回溯的理想应用。一般的想法是从 16 个字母立方体中的每个立方体开始进行搜索，递归探索从起点开始的所有路径，并跟踪其相邻立方体。
- 标记。你不想在给定的探索中访问同一字母立方体两次，因此你的搜索需要某种方法来“标记”是否访问过字母立方体。你如何管理标记的选择取决于你；任何高效和有效的选择对我们来说都可以。

### 注意事项

- 使用 ADT。你之前使用的 `Grid/GridLocation` 和 `Lexicon` 将派上用场。你也可以使用斯坦福库中的其他 ADT。注意选择符合作业要求的高效数据结构。由于复制大型数据结构可能很浪费资源，因此请通过引用传递这些变量，以便在不复制的情况下进行高效操作。
- 英语词典。我们的 `EnglishWords.txt` 词典包含超过 12.5 万个单词，是普通人词汇量的四倍。凭借着大量晦涩的单词和递归穷举的力量，你实现的版本将很难被击败！
- 辅助函数。初始代码包括一些原型和测试用例，可以用来测试推荐的辅助函数。你也可以使用你喜欢的任何参数，自行设计其他的辅助/包装函数。唯一要求是，函数 scoreBoard 的使用与上面的原型完全匹配。
- 效率。为拼字盘计分应该是即时的，不到一秒钟。这将需要有效的 ADT 选择（见上文）和明智的精简操作（见下文）。
- 精简。优化任何穷举递归的一个重要考虑因素是去除无效分支的搜索。`Lexicon` 中的 containsPrefix 函数会判断单词是否以给定的前缀开头。如果你检查的第一个立方体是字母Z，其邻居是 X，则初始路径为 ZX。函数 `lex.containsPrefix("ZX")` 的调用将返回 false， 通知你词典中不包含以此前缀开头的单词。搜索应该放弃这条路径，转向其他更有希望的组合。如果你未能应用此优化，你会发现执行时间会变得非常长，计算机会徒劳地寻找 zxgub、zxaep 等单词。

恭喜你！随着你在这个任务上的成功，你现在正在通往递归大师的道路上！你已经有了一个外挂，在和你的朋友和家人竞赛时，可以让你赢得所有人。

## 第三部分 投票系统

> 解决这个颇具挑战性的问题，将会是你成为递归大师的旅程中，做的最后一点收尾工作。这个挑战性问题会研究一个街区投票系统，比如美国大选机制。

### 区块投票系统

> “民主不在于投票，而在于计票。” —— 汤姆 · 斯托帕德，Jumpers

据说“每张选票都很重要”，但是每张选票都是平等的吗？在回答这个问题时，我们将特别关注集体投票制度，例如美国选举团制度。在一个区块投票系统中，每个区块有不同数量的指定票，并且每一个区块的投票方式都是相同的。

在美国系统中，每个州是一个区块，根据其人口规模有特定数量的选票（有趣的事实：除了内布拉斯加州和缅因州！）。由于对某一特定区块的所有投票结果都是相同的，州内的选举决定了该区块作为一个整体投票的方向。这意味着如果在 A 和 B 之间进行全国选举，即使加利福尼亚州 10% 的选民支持 B，加利福尼亚州所有的集体选票都会投给 A，因为 A 赢得了该州的多数票。

加利福尼亚州有 55 张选票，而新墨西哥州有 5 张选票，因为加利福尼亚州有更多的人口。你可能会问：这是否意味着加利福尼亚州的选举结果影响力是新墨西哥州的 10 倍？让我们进一步探索！

考虑在给定的选举中 n 个投票区块可以投票的所有可能方式。在一个只有两个候选人的选举中，总共有 2^n 个可能的结果。衡量一个区块的重要性或投票“权力”的一个指标是在选举结果中，该区块符合我们所说的“关键选票”的次数。“关键选票”是可以改变选举结果的一票。虽然在技术上，一个区块内有多个选票，但是当我们谈论一个区块是否为一个“关键选票”时，我们只使用单独的“一票”来看待，因为所有给定区块的投票都朝向一个特定的结果（即，他们都是以相同的方式投出的）。在所有选举结果中，一个区块拥有的“关键选票”的次数，可以用来计算 Banzhaf Power Index，该指数表示一个给定区块在一个选举系统中拥有的投票影响力指数。

### Banzhaf 影响力指数

将联盟（coalition）定义为在特定选举中以相同方式投票的一组区块（block）。对于一个给定的投票区块 B，如果没有 B 就会输掉选举；如果有 B 就会赢得选举，那么 B 称为关键选票。也就是说，B 能够左右选举的结果。

考虑一下这个由三个投票区组成的示例系统：Lions（50），Tigers（49），Bears（1）

首先，让我们列举一下可能的投票联盟结果：

Lions+Tigers+Bears, Lions+Tigers, Lions+Bears, Tigers+Bears, Lions, Tigers, Bears

假设赢得选举需要绝对多数。这个制度总共有 100 张选票，所以一个获胜的联盟必须积累 51 张或更多的选票才能获得多数票。

以上 7 个结果中，有 3 个是获胜联盟。那么对于每个获胜联盟，我们可以统计关键选票的数量：

- Lions+Tigers+Bears 如果没有 Lions（50）组合必输，所以 Lions 是关键选票；而 Tiger（49） 或 Bears（1） 任何一方丢掉，都不影响组合获胜，所以这两个都不是关键选票。
- Lions+Tigers 如果没有 Lions（50）组合必输；同样，没有 Tigers（49）组合也会输，所以这两个都是关键选票。
- Lions+Bears  如果没有 Lions（50）组合必输；同样，没有 Bears（1）组合也会输，所以这两个都是关键选票。

计算每个区块的关键选票出现的次数，我们得到以下数据：Lions（3），Tigers（1），Bears（1）

Banzhaf 影响力指数用于表示一个区块的投票权重，即该区块在所有关键选票总数中所占的百分比。要将关键选票的计数转换为影响力指数，将系统中的所有关键选票合计，并计算每个块的关键选票的百分比。转换后的结果如下：Lions（60%），Tigers（20%），Bears（20%）

所有区块的影响力指数之和为 100% 。通过比较相对百分比，可以看出各区块投票权重的差异。尽管 Tigers 的票数要大得多，Tigers 和 Bears 却拥有相同的投票权重。Lions 的票数小幅上升使得他们的投票权重是 Tigers 的三倍。显然，赢得 Lions 将会得到更多的选票！（这样的现实……我们无法抗拒！）

### 你的任务

你需要实现如下函数：

```c++
Vector<int> computePowerIndexes(Vector<int>& blocks)
```

它接收一个大小为 N 的向量，其中包含一个街区投票系统的区块计数。该函数计算关键选票，以确定每个区块的投票权。该函数返回的输出是一个大小为 N 的向量，其中每个区块都有自己 Banzhaf 影响力指数。例如，在区块计数为 `{50,49,1}` 的向量上调用 `computePowerIndex` 将返回每个区块的影响力指数向量 `{60,20,20}`。

虽然上面的解释描述了首先要找到获胜的联盟，然后再确定哪些参与者是关键的，但是实际的代码更容易构建，可以持续计算特定于某个目标区块的关键选票，并对所有区块重复该过程。

- 取出目标区块，并递归地探索所有不包括该目标区块的子集（联盟）。当你组成一个联盟时，你不需要存储该区块的集合，只需计算每个联盟的累积选票总数。
- 一旦一个联盟形成，其选票总数就确定了，我们就可以考虑目标区块的影响力。如果没有目标区块，联盟就会失败吗？如果有目标区块，联盟就会赢吗？如果这两个问题的答案都是肯定的，那么这个目标区块就是这个联盟的关键选票。
- 对系统中的每个区块重复探索，以计算每个区块是否为关键选票。
- 一旦你得到了所有区块的关键选票计数，转换到百分比就是简单的循环和算术了。

在测试和调试函数之后，预测 computePowerIndex 函数的大 O 是什么。然后使用计时操作来测量超过 5 个或更多不同大小的执行时间。选择合适的大小，以便最大的操作在一分钟左右完成。

> Q6. 函数 computePowerIndex 的大 O 是多少？包括你的计时数据并解释它如何支持你的推理。

> Q7. 使用大 O 和计时数据来估计计算美国选举团中 51 个投票区的影响力指数需要多长时间。

### 注意事项

- 平局。为了赢得选举，联盟必须获得严格的多数选票，平局不被视为获胜的联盟。
- 舍入。我们将影响力指数计算为一个整数，这是一个舍入的值（确切地说，小数部分会被截掉）。所以最终的影响力指数总和可能是 99 而不是 100。
- 递归思路。可以参考类似子集探索的经典包含/排除模式的代码。
- 效率。尝试所有子集的穷举递归，在计算上是非常耗时的。以下是一些可以克服资源匮乏的方法：
  - 一旦发现无论目标区块是否参与，联盟都将获胜，就没有必要进一步探索这条道路。目标区块不可能成为这个联盟中的关键选票。
  - 在使用 ADT 时要深思熟虑，并注意避免不必要的复制操作（ADT 作为参数传值或从函数返回时，都将产生复制操作）。
  - 此外，不要试图首先构建所有联盟的子集，然后再处理联盟。考虑到一个投票系统，即使只有少量的块，仍然会消耗大量的内存。相反，你必须一次探索一个联盟：先组建出一个联盟，测试它，取消选择并回溯，然后再组建另一个联盟，不断地探索。在任何时候，只有一个组建好的联盟会存放在内存中。
- 重复/重新计算。系统中的两个或多个区块可以具有相同数量的选票；具有相等票数的区块，其关键投票数将相同。在作业里，可以不用特殊对待这种重复操作，重新计算每个区块的关键投票数也是可以的（当然，没人会阻止你持续优化，可以利用一些技术避免重复计算）。
- 辅助函数。灵活利用包装函数。

## 作业提交 💯

检查以下文件是否都已完成：

- warmup.cpp
- boggle.cpp
- voting.cpp
- 测试运行结果截图

文件夹内 Qt 生成的其他文件，记得删除！
